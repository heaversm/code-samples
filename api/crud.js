
// Simple CRUD API to:
// Collect a user's name, email, optin, and favorite 5 integers to store in a google firebase DB
// Read submissions from the DB...
// Update by ID or 
// Delete by ID                                                                                                                     

const functions = require('firebase-functions'); //create cloud functions
const admin = require('firebase-admin'); //enables functions to control backend services
const express = require('express'); //web server
const cors = require('cors'); //lets functions run separate from client
const { check, validationResult } = require('express-validator'); //validate data
const app = express(); //routing
app.use(cors({ origin: true })); //allow cross origin resource sharing


var serviceAccount = require("./superthings-5c8f5-firebase-adminsdk-m1hiu-f28f79e984.json"); //specify location of private key generated by Firebase for connecting to DB

admin.initializeApp({
    credential: admin.credential.cert(serviceAccount), //use private key to auth database access
    databaseURL: "https://superthings-5c8f5.firebaseio.com" //specify the URL to database from firebase console
});

const db = admin.firestore(); //initialize database

app.get('/hello-world', (req, res) => { //test basic server connectivity
    return res.status(200).send('Hello World!');
});

app.post('/api/create', [ //validators
    check('fullName').isString(),
    check('email').isEmail().normalizeEmail(), //validate and normalize email
    check('favoriteFiveIntegers').isArray(), //TODO - validate array contains integers
    check('emailOptIn').isBoolean().toBoolean(),
], (req, res) => { //create a an item within our collection. Accepts raw data of the format { id: 1, item: "First Item" }. For testing database only

    const errors = validationResult(req); //get any errors 

    if (!errors.isEmpty()) { //if there are errors, return them to front end
        return res.status(422).json({ errors: errors.array() }); //unprocessable entity
    }

    if (req.body.favoriteFiveIntegers.length !== 5){
        return res.status(422).json({
            errors: [
                {
                    "value": req.body.favoriteFiveIntegers,
                    "msg": "Array should contain five integers",
                    "param": "favoriteFiveIntegers",
                    "location": "body"
                }
            ]
        })
    }

    const invalidIntArray = [];

    req.body.favoriteFiveIntegers.forEach((intVal,index)=>{
        if (!Number.isInteger(intVal)){
            const invalidIntObj = {
                "value": intVal,
                "msg": "Array values must be integers",
                "param": "favoriteFiveIntegers",
                "location": "body",
                "array index": index,
            }
            invalidIntArray.push(invalidIntObj);
        }
    });

    if (invalidIntArray.length){
        return res.status(422).json({
            errors: invalidIntArray
        });
    }


    (async () => {
        try {
            //await db.collection('items').doc('/' + req.body.id + '/') //for explicit ids
            await db.collection('items').doc() //for ids auto-generated by firebase
                .create({ 
                    fullName: req.body.fullName, //string
                    email: req.body.email, //string
                    dateOfBirth: new Date(req.body.dateOfBirth), //date
                    favoriteFiveIntegers: req.body.favoriteFiveIntegers, //array
                    emailOptIn: req.body.emailOptIn, //boolean
                    timeOfRegistration: Date.now() //timestamp
                });
            return res.status(200).send();
        } catch (error) {
            console.log(error);
            return res.status(500).send(error);
        }
    })();
    return false;
});

// read item by ID
app.get('/api/read/:item_id', (req, res) => {
    (async () => {
        try {
            const document = db.collection('items').doc(req.params.item_id);
            let item = await document.get();
            let response = item.data();
            return res.status(200).send(response);
        } catch (error) {
            console.log(error);
            return res.status(500).send(error);
        }
        })();
    });

// read all items
app.get('/api/read', (req, res) => {
    (async () => {
        try {
            let query = db.collection('items');
            let response = [];
            await query.get().then(querySnapshot => {
            let docs = querySnapshot.docs;
            for (let doc of docs) {
                const selectedItem = {
                    id: doc.id,
                    item: doc.data().item
                };
                response.push(selectedItem);
            }
            return true;
            });
            return res.status(200).send(response);
        } catch (error) {
            console.log(error);
            return res.status(500).send(error);
        }
        })();
    });

// update
//app.put('/api/update/', (req, res) => { //if we wanted to get via a query param vs URL param
app.put('/api/update/:item_id', (req, res) => {
(async () => {
    try {
        //if we wanted to get via a query param vs URL param:
        //const item_id = req.param('item_id'); 
        //const document = db.collection('items').doc(item_id);

        //get via URL param
        const document = db.collection('items').doc(req.params.item_id); 

        //resume normal
        await document.update({
            item: req.body.item
        });
        return res.status(200).send();
    } catch (error) {
        console.log(error);
        return res.status(500).send(error);
    }
    })();
});

// delete
app.delete('/api/delete/:item_id', (req, res) => {
(async () => {
    try {
        const document = db.collection('items').doc(req.params.item_id);
        await document.delete();
        return res.status(200).send();
    } catch (error) {
        console.log(error);
        return res.status(500).send(error);
    }
    })();
});


exports.app = functions.https.onRequest(app); //expose app for requests